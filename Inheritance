# 2.1 Inheritance

## 1. What is Inheritance?

**Inheritance** is a fundamental concept in Object-Oriented Programming (OOP) that promotes code reusability and maintainability.

Key Definition:

If class A `is` a specialized version of class B, then we say A inherits from B. In this relationship, class B is known as the **superclass** (or **parent class**), while class A is the **subclass** (or **child class**). To establish inheritance, the subclass declaration should include `extends B`.

Examples:
* A `Cat` is a specific type of `Animal`, so `Cat` is the subclass, and `Animal` is the superclass.
* A `Basketball` is a specific type of `Ball`, making `Basketball` the subclass and `Ball` the superclass.

```java
public class Cat extends Animal {		// Cat is a special kind of Animal
}
```

Note: â€œX contains/has Yâ€ does not represent inheritance. In such cases, Y should be defined as a data member within X.

Example: A `Library` contains `Book`, meaning `Book` should be a field (attribute) of `Library`, not a subclass.

```java
public class Library {
    private ArrayList<Book> books;		// Library contains Book 
}
```

Inheritance can form a chain. For example, a `Cat` is a specialized type of `DomesticatedAnimal`, and a `DomesticatedAnimal` is a specialized type of `Animal`.

```java
public class DomesticatedAnimal extends Animal{		// DomesticatedAnimal is a special kind of Animal
}

public class Cat extends DomesticatedAnimal{		// Cat is a special kind of DomesticatedAnimal
}
```

Inheritance resembles a family tree. In the previous example, `Animal`, `DomesticatedAnimal`, and `Cat` form a â€œfamilyâ€ or, more technically, a **hierarchy**. This means they all belong to the same hierarchy.

## 2. The Advantages of Inheritance

When class `A` (a subclass) inherits from class `B` (a superclass), it automatically includes all non-private members (both fields and methods) of `B`.

For example, if the superclass `Animal` has the attributes `name` and `age`, its subclass `Dog` will inherit these attributes without needing to redefine them.

```java
// Animal Class with 2 data members and 4 methods (getters and setters)
@Getter
@Setter
public class Animal {
    private String name;
    private int age;
}
```

```java
// Dog class extends from Animal class, so it will get all data members and methods from it
// There are 1 data member and 2 methods defined in this class, but it also gets the 2 data members and 4 methods from the super classs, so totally there are 3 data members and 6 methods in the Dog class.
@Getter
@Setter
public class Dog extends Animal {
	private int sportHour;
}
```

If a superclass has multiple subclasses, inheritance helps keep the code clean and organized.

For example, suppose you have a superclass `Animal` with five subclasses: `Dog`, `Cat`, `Monkey`, `Tiger`, and `Duck`. Without inheritance, each subclass would need to define the `name` and `age` attributes along with their getters and setters separately. Since these members are identical across all subclasses, the code would become repetitive (WET code) and harder to maintain.

## 3. Example of Inheritance

When implementing a class hierarchy, always follow a **top-down** approachâ€”start by defining the superclass, then proceed with subclasses, and further down to sub-subclasses as needed.

### 3.1 Defining the Superclass

At this stage, defining the top-level superclass is no different from creating a regular class before introducing inheritance.

### 3.2 Defining a Subclass

#### 3.2.1 Defining Constructors

A subclass may inherit some data members from its superclass while also introducing its own. Its constructor should initialize all data members, including those inherited from the superclass.

Since the superclass already provides constructors to initialize its attributes, there is no need to redefine them in the subclass. Instead, you can call the superclass constructor using the super keyword.

Important: A call to the superclass constructor must be the first statement in the subclass constructor.

For example, in the `Dog` class (which extends `Animal`), `super()` calls the default constructor of `Animal`, initializing the inherited attributes.

```java
/**
 * Animal Class with 3 constructors
 */
@AllArgsConstructor
@NoArgsConstructor
public class Animal {
    private String name;
    private int age;
    
    public Animal(Animal animal) {
        this.name = animal.name;
        this.age = animal.age;
    }
}
```

```java
/**
 * Dog class with 1 additional data member
 */
@NoArgsConstructor
public class Dog extends DomesticatedAnimal {
    private int sportHour;

    public Dog(Stirng name, int age, int sportHour) {
        super(name, age);			// calling the all arguments constructor in the Animal class
        this.sportHour = dog.sportHour;
    }

    public Dog(Dog dog) {
        super(dog);			// calling the copy constructor in the Animal class
        this.sportHour = dog.sportHour;
    }
}
```

## 4. The Object Class

In Java, there is a special class called `Object`, which serves as the root of all classes. Technically, every class in Java extends from `Object`, either explicitly or implicitly.

The Object class provides some fundamental methods, such as `toString()` and `equals()`, which are automatically available in any class that extends from it.

5. Access Modifiers

Java provides four access modifiers to control the visibility of class members: public, private, protected, and default.

* `public`: No restrictionsâ€”any class from any package can access the member.
* `private`: The strictest restrictionâ€”only accessible within the same class.
* `protected`: Accessible by:
    1. The class itself.
    2. Subclasses within the same hierarchy.
    3. Other classes within the same package.
* `default` (also known as `package-private`): If no modifier is specified, the member is accessible only within the same package.
  
## 6. Casting

In Programming 1, you learned about primitive data types and type casting. There are two main types of casting:

1.	Auto-Casting (Implicit Casting):
Java automatically converts a smaller or less precise data type to a larger or equally precise type. For example, 

    ``` java
    double num = 3;  // int to double
    int num2 = 'a';
    ```

2. 	Manual Casting (Explicit Casting):
When converting a more precise or larger data type to a less precise one, Java requires explicit casting using (type). For example,

``` java
int num = (int) 3.14;  // double to int
```

3.	Casting Between Classes in the Same Hierarchy:
Objects in the same inheritance hierarchy can also be cast.
    * Subclass to Superclass (**Upcasting**):
    A superclass reference can point to a subclass object.
    
        ``` java
        Animal animal = new Dog();  // Dog is upcast to Animal
        ```

        The actual object remains a `Dog`, but since it is referenced as an `Animal`, it can only access methods defined in `Animal`.
        Think of it like a prince turned into a frogâ€”deep inside, itâ€™s still a prince, but it can only act like a frog (jump instead of walk).

    * Superclass to Subclass (**Downcasting**):
    
        A superclass reference can be cast to a subclass only if the object was originally created as that subclass. For example,

        ``` java
        // unsafe downcasting
        Animal animal = new Animal();  
        Dog dog = (Dog) animal;  // ERROR: `animal` is not actually a `Dog`, Java does not know what values to put for the Dog data members
        ```

        To avoid errors, use instanceof before downcasting:

        ``` java
        if (animal instanceof Dog) {
            Dog dog = (Dog) animal;
        }
        ```

        Let's take a look at this example: 

        ```java
        public class Animal {
            public void eat() {
            }
            
            public void sleep() {
            }
        }
        ```

        ```java
        public class Dog extends Animal{
            public void playWithHuman() {
            }
        }
        ```

        ```java
        public static void main() {
            Dog d = new Dog(); 			// d can eat, sleep and playWithHuman
            Aniumal a = new Dog();		// a can only eat and sleep, but not playWithHuman
            
            Dog d2 = (Dog) a;			// a is casted to a Dog, now it can eat, sleep and playWithHuman
            Dog d3 = (Dog) new Animal(); // Error, the object is Animal, cannot be casted to Dog
        }
        ```

## 7. Instanceof

In the previous example, we have two classes `Animal` and `Dog`, if we introduce another class `Cat` extends from `Animal` and a `Zoo` class that contains different animals (only cat and dog here) inside.

```java
// Superclass
class Animal {
    protected String name;

    public Animal(String name) {
        this.name = name;
    }

    public void makeSound() {
        System.out.println("Some generic animal sound");
    }
}

// Subclass Dog
class Dog extends Animal {
    public Dog(String name) {
        super(name);
    }

    @Override
    public void makeSound() {
        System.out.println(name + " says: Woof!");
    }
}

// Subclass Cat
class Cat extends Animal {
    public Cat(String name) {
        super(name);
    }

    @Override
    public void makeSound() {
        System.out.println(name + " says: Meow!");
    }
}

// Zoo class to store animals
class Zoo {
    private List<Animal> animals;

    public Zoo() {
        animals = new ArrayList<>();    // have to use the keywoed `new` to create the ArrayList, or it will be set as `null`
    }

    public void addAnimal(Animal animal) {
        animals.add(animal);
    }

    public void makeAllAnimalsSound() {
        for (Animal animal : animals) {
            animal.makeSound();
        }
    }
}

// Main class to test
public class Main {
    public static void main(String[] args) {
        Zoo zoo = new Zoo();
        
        Dog dog = new Dog("Buddy");
        Cat cat = new Cat("Whiskers");
        
        zoo.addAnimal(dog);
        zoo.addAnimal(cat);
        
        zoo.makeAllAnimalsSound();
    }
}
```

When adding `Dog` or `Cat` objects to the animals list, Java automatically upcasts them to `Animal`, since the list is declared as `List<Animal>`.

* Issue with Calling Subclass-Specific Methods

    Once an object is stored in animals, we cannot directly call subclass-specific methods like `playWithHuman()` from `Dog` because the reference type is `Animal`.

    To access `playWithHuman()`, we must downcast the `Animal` object back to `Dog`. However, not all animals are dogs, so attempting to cast a `Cat` to a `Dog` would cause a runtime error.

* Solution: Using `instanceof` to Check Before Casting

    Java provides the instanceof operator to check an objectâ€™s actual type before casting.

    ```java
    public static void main() {
        Animal a = new Dog();						   // the real type is Dog
        System.out.print(a instanceof Dog);				// true, Dog is Dog
        System.out.print(a instanceof Animal);           // true, Dog is subclass of Animal
        System.out.print(a instanceof Cat);				// false, Dog is not Cat or subclass of Cat
    }
    ```

    Back to the previous example, if we want all dogs in the zoo to play with humans, we can use the following code:

    ```java
    public static void main() {
        `````
        for (Animal animal : animals) {
            if (animal instanceof Dog) {  	// only if the animal is Dog
                ((Dog) animal).playWithHuman();			// cast it to Dog, then call the playWithHuman() method
            }
        }
    }
    ```

    Since Java 16, we can also directly create a reference for the new object without manually casting while using `instanceof`

    ```java
    public static void main() {
        `````
        for (Animal animal : animals) {
            if (animal instanceof Dog dog) {  	
                // if animal is instance of Dog, then a Dog reference dog will be created.
                dog.playWithHuman();			// call the playWithHuman() method directly from the dog reference
            }
        }
    }
    ```
